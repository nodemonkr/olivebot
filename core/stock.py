# stock.py (Ï†ÅÏö©Îêú Ï£ºÍ∞Ä Î™®Îç∏ ÌÜµÌï© + Î™ÖÎ†πÏñ¥ Ï†ÑÏ≤¥ Ìè¨Ìï®)

import discord
from discord import app_commands
from discord.ext import tasks
import json, random, os
from datetime import datetime, timedelta
from core.utils import load_data, save_data
import asyncio
import matplotlib.pyplot as plt
import matplotlib
import numpy as np
from typing import List
import random

# ÌïúÍ∏Ä Íπ®Ïßê Î∞©ÏßÄ ÏÑ§Ï†ï
matplotlib.rcParams['font.family'] = 'Malgun Gothic'  # Windows Í∏∞Ï§Ä
matplotlib.rcParams['axes.unicode_minus'] = False

class StockNameConverter(app_commands.Transformer):
    async def transform(self, interaction: discord.Interaction, value: str) -> str:
        return value

    async def autocomplete(self, interaction: discord.Interaction, current: str) -> List[app_commands.Choice[str]]:
        with open("data/stock_data.json", "r", encoding="utf-8") as f:
            stock_data = json.load(f)

        return [
            app_commands.Choice(name=name, value=name)
            for name in stock_data.keys()
            if current.lower() in name.lower()
        ][:25]

DATA_FILE = "data/stock_data.json"
USER_FILE = "data/users.json"
NEWS_FILE = "data/news_data.json"
SETTINGS_FILE = "data/stock_settings.json"
TRADE_LOG_FILE = "data/trade_log.json"

ADMIN_IDS = [1047192081828941845]
MAX_USER_TOTAL_SHARES = 10

def load_json(path, default={}):
    if not os.path.exists(path) or os.path.getsize(path) == 0:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(default, f, ensure_ascii=False, indent=2)
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def save_json(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def get_settings():
    default = {"price_ceiling": 0.05}
    settings = load_json(SETTINGS_FILE, default)
    default.update(settings)
    return default

def update_trade_log(name: str, qty: int, action: str):
    trades = load_json(TRADE_LOG_FILE)
    trades.setdefault(name, {"buy": 0, "sell": 0})
    trades[name][action] += qty
    save_json(TRADE_LOG_FILE, trades)

def random_market_change():
    roll = random.random()
    if roll < 0.1:
        return random.uniform(+0.03, +0.05)  # ÌÅ∞ ÏÉÅÏäπ
    elif roll < 0.3:
        return random.uniform(+0.01, +0.03)  # Ï§ëÍ∞Ñ ÏÉÅÏäπ
    elif roll < 0.7:
        return random.uniform(-0.01, +0.01)  # ÏïΩÌïú Î≥ÄÎèô
    elif roll < 0.9:
        return random.uniform(-0.03, -0.01)  # Ï§ëÍ∞Ñ ÌïòÎùΩ
    else:
        return random.uniform(-0.05, -0.03)  # ÌÅ∞ ÌïòÎùΩ


def update_stock_prices():
    stocks = load_json(DATA_FILE)
    trades = load_json(TRADE_LOG_FILE)
    news = load_json(NEWS_FILE)
    settings = get_settings()
    today = datetime.now().strftime("%Y-%m-%d")

    result = []
    for name, s in stocks.items():
        if s.get("delisted", False):
            continue

        tlog = trades.get(name, {})
        demand = tlog.get("buy", 0)
        supply = tlog.get("sell", 0)
        total = demand + supply if demand + supply > 0 else 1
        demand_supply_rate = (demand - supply) / total * 0.02

        manual_bias = tlog.get("bias")
        trend_bias = manual_bias if manual_bias is not None else 0

        for n in news.get(name, []):
            if not n.get("applied") and n["date"] <= today:
                trend_bias += (n["influence"] - 3) * 0.01
                n["applied"] = True

        base_change = random_market_change()
        change = base_change + demand_supply_rate + trend_bias
        change = min(max(change, -settings["price_ceiling"]), settings["price_ceiling"])

        old_price = s["price"]

        # ‚úÖ ÏµúÏ¥à Ï¥àÍ∏∞Í∞í ÏÑ§Ï†ï
        if "initial" not in s:
            s["initial"] = old_price
        initial_price = s["initial"]

        new_price = int(old_price * (1 + change))
        new_price = max(1, min(new_price, int(initial_price * 2)))

        s["price"] = new_price
        s.setdefault("history", []).append(new_price)
        if len(s["history"]) > 10:
            s["history"] = s["history"][1:]
        s["last_updated"] = today

        result.append(f"{name}: {old_price} ‚Üí {new_price} ({change*100:+.2f}%)")

        trades[name]["buy"] = 0
        trades[name]["sell"] = 0
        if manual_bias is not None:
            trades[name]["bias"] = manual_bias

    save_json(DATA_FILE, stocks)
    save_json(NEWS_FILE, news)
    save_json(TRADE_LOG_FILE, trades)
    return result
def setup(bot):
    async def stock_name_autocomplete(interaction: discord.Interaction, current: str):
        stocks = load_json(DATA_FILE)
        options = [name for name in stocks if current.lower() in name.lower() and not stocks[name].get("delisted")]
        return [app_commands.Choice(name=name, value=name) for name in options[:25]]

    @bot.tree.command(name="ÏãúÏû•Í∞±Ïã†", description="Î™®Îì† Ï£ºÏãùÏùò Í∞ÄÍ≤©ÏùÑ Í∞±Ïã†Ìï©ÎãàÎã§.")
    async def ÏãúÏû•Í∞±Ïã†(interaction: discord.Interaction):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return
        result = update_stock_prices()
        await interaction.response.send_message("\n".join(result), ephemeral=True)

    @bot.tree.command(name="Ï£ºÏãùÍµ¨Îß§", description="Ï£ºÏãùÏùÑ Íµ¨Îß§Ìï©ÎãàÎã§.")
    @app_commands.describe(name="Ï¢ÖÎ™©", qty="Íµ¨Îß§ ÏàòÎüâ")
    @app_commands.autocomplete(name=stock_name_autocomplete)
    async def Ï£ºÏãùÍµ¨Îß§(interaction: discord.Interaction, name: str, qty: int):
        user_id = str(interaction.user.id)
        users = load_json(USER_FILE)
        stocks = load_json(DATA_FILE)
        settings = get_settings()

        if name not in stocks or stocks[name].get("delisted"):
            await interaction.response.send_message("Ï°¥Ïû¨ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÏÉÅÏû•ÌèêÏßÄÎêú Ï¢ÖÎ™©ÏûÖÎãàÎã§.", ephemeral=True)
            return

        user = users.setdefault(user_id, {"olive": 0, "stocks": {}})
        user.setdefault("stocks", {})
        user["stocks"] = {k: v for k, v in user["stocks"].items() if v.get("qty", 0) > 0}

        def user_total_stocks(user_data: dict) -> int:
            user_data.setdefault("stocks", {})
            return sum(p.get("qty", 0) for p in user_data["stocks"].values() if p.get("qty", 0) > 0)

        if user_total_stocks(user) + qty > MAX_USER_TOTAL_SHARES:
            await interaction.response.send_message(f"‚ùå Î≥¥Ïú† Í∞ÄÎä•Ìïú Ï¥ù Ï£ºÏãù Ïàò({MAX_USER_TOTAL_SHARES}Ï£º)Î•º Ï¥àÍ≥ºÌï©ÎãàÎã§.", ephemeral=True)
            return

        price = stocks[name]["price"]
        total = int(price * qty * (1 + settings["fee_rate"]))

        if user["olive"] < total:
            await interaction.response.send_message("‚ùå Ïò¨Î¶¨Î∏åÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.", ephemeral=True)
            return

        user["olive"] -= total
        holding = user["stocks"].get(name, {"qty": 0, "avg": 0})
        total_qty = holding["qty"] + qty
        holding["avg"] = int((holding["avg"] * holding["qty"] + price * qty) / total_qty)
        holding["qty"] = total_qty
        user["stocks"][name] = holding

        stocks[name]["last_trade"] = datetime.now().strftime("%Y-%m-%d")

        save_json(USER_FILE, users)
        save_json(DATA_FILE, stocks)
        update_trade_log(name, qty, "buy")

        await interaction.response.send_message(f"‚úÖ {name} Ï£ºÏãù {qty}Ï£ºÎ•º Íµ¨Îß§ÌñàÏäµÎãàÎã§.\nüìä ÌèâÍ∑†Îã®Í∞Ä: {holding['avg']} Ïò¨Î¶¨Î∏å", ephemeral=True)

    @bot.tree.command(name="Ï£ºÏãùÌåêÎß§", description="Î≥¥Ïú†Ìïú Ï£ºÏãùÏùÑ ÌåêÎß§Ìï©ÎãàÎã§.")
    @app_commands.describe(name="Ï¢ÖÎ™©", qty="ÌåêÎß§ ÏàòÎüâ")
    @app_commands.autocomplete(name=stock_name_autocomplete)
    async def Ï£ºÏãùÌåêÎß§(interaction: discord.Interaction, name: str, qty: int):
        users = load_json(USER_FILE)
        stocks = load_json(DATA_FILE)
        settings = get_settings()
        uid = str(interaction.user.id)

        if name not in stocks or stocks[name].get("delisted"):
            await interaction.response.send_message("Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ï¢ÖÎ™©ÏûÖÎãàÎã§.", ephemeral=True)
            return

        users.setdefault(uid, {"olive": 0})
        if "stocks" not in users[uid]:
            users[uid]["stocks"] = {}

        if name not in users[uid]["stocks"]:
            await interaction.response.send_message("Ìï¥Îãπ Ï¢ÖÎ™©ÏùÑ Î≥¥Ïú†ÌïòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.", ephemeral=True)
            return

        p = users[uid]["stocks"][name]
        if p["qty"] < qty:
            await interaction.response.send_message("Î≥¥Ïú† ÏàòÎüâÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§.", ephemeral=True)
            return

        price = stocks[name]["price"]
        receive = int(price * qty * (1 - settings["fee_rate"]))
        p["qty"] -= qty

        if p["qty"] == 0:
            users[uid]["stocks"].pop(name)
        users[uid]["olive"] += receive
        stocks[name]["last_trade"] = datetime.now().strftime("%Y-%m-%d")

        save_json(USER_FILE, users)
        save_json(DATA_FILE, stocks)
        update_trade_log(name, qty, "sell")

        await interaction.response.send_message(f"‚úÖ {name} {qty}Ï£º ÌåêÎß§ ÏôÑÎ£å (ÏàòÎ†π: ü´í{receive}Í∞ú Ïò¨Î¶¨Î∏å)", ephemeral=True)

    # ... ÏïûÎ∂ÄÎ∂Ñ ÏÉùÎûµ ...

    @bot.tree.command(name="Ìè¨Ìä∏Ìè¥Î¶¨Ïò§", description="ÏûêÏã†Ïùò Ï£ºÏãù Î≥¥Ïú† ÌòÑÌô©ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.")
    async def Ìè¨Ìä∏Ìè¥Î¶¨Ïò§(interaction: discord.Interaction):
        users = load_json(USER_FILE)
        stocks = load_json(DATA_FILE)
        uid = str(interaction.user.id)
        users.setdefault(uid, {"olive": 0})
        if "stocks" not in users[uid]:
            users[uid]["stocks"] = {}

        msg = ["üìÇ ÎÇ¥ Ìè¨Ìä∏Ìè¥Î¶¨Ïò§"]
        total = 0
        for name, p in users[uid]["stocks"].items():
            if name in stocks:
                cur = stocks[name]["price"]
                eval_price = cur * p["qty"]
                diff = cur - p["avg"]
                msg.append(f"{name}: {p['qty']}Ï£º (Íµ¨Îß§Í∞Ä ü´í{p['avg']} ‚Üí ÌòÑÏû¨ ü´í{cur} / ÏÜêÏùµ ü´í{diff:+})")
                total += eval_price
        msg.append(f"Ï¥ù ÌèâÍ∞ÄÏï°: ü´í{total}Í∞ú Ïò¨Î¶¨Î∏å")
        await interaction.response.send_message("\n".join(msg), ephemeral=True)

    # @bot.tree.command(name="Ï£ºÏãùÏ†ïÎ≥¥", description="Ï¢ÖÎ™©Ïùò ÌòÑÏû¨Í∞ÄÏôÄ Ï∂îÏÑ∏Î•º ÌôïÏù∏Ìï©ÎãàÎã§.")
    # @app_commands.describe(name="Ï°∞ÌöåÌï† Ï¢ÖÎ™© Ïù¥Î¶Ñ")
    # @app_commands.autocomplete(name=stock_name_autocomplete)
    # async def Ï£ºÏãùÏ†ïÎ≥¥(interaction: discord.Interaction, name: str):
    #     stocks = load_json(DATA_FILE)
    #     s = stocks.get(name)
    #     if not s or s.get("delisted"):
    #         await interaction.response.send_message("Ï°¥Ïû¨ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÏÉÅÏû•ÌèêÏßÄÎêú Ï¢ÖÎ™©ÏûÖÎãàÎã§.", ephemeral=True)
    #         return
    #     history = s.get("history", [s["price"]])
    #     prev = history[-2] if len(history) >= 2 else s["price"]
    #     rate = (s["price"] - prev) / prev * 100 if prev else 0
    #     msg = f"üìä {name}\nÌòÑÏû¨Í∞Ä: ü´í {s['price']}Í∞ú Ïò¨Î¶¨Î∏å\nÎì±ÎùΩÎ•†: {rate:+.2f}%"
    #     await interaction.response.send_message(msg, ephemeral=True)

    @bot.tree.command(name="Ï£ºÏãùÏôï", description="ÏàòÏùµÎ•† Í∏∞Ï§Ä Ï£ºÏãù Îû≠ÌÇπÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.")
    async def Ï£ºÏãùÏôï(interaction: discord.Interaction):
        await interaction.response.defer()  # ÏùëÎãµ ÏòàÏïΩ

        users = load_data()
        stocks = load_json("data/stock_data.json")

        ranking = []
        for uid, udata in users.items():
            udata.setdefault("stocks", {})
            profit = 0
            for name, p in udata["stocks"].items():
                if name in stocks:
                    cur = stocks[name]["price"]
                    profit += (cur - p["avg"]) * p["qty"]
            ranking.append((uid, profit))

        ranking.sort(key=lambda x: x[1], reverse=True)  # ÏÉÅÏúÑ 10Î™Ö Ï†ïÎ†¨
        top10 = ranking[:10]

        async def get_name(user_id):
            try:
                member = interaction.guild.get_member(int(user_id)) or await interaction.guild.fetch_member(int(user_id))
                return member.display_name
            except Exception:
                return f"Ïú†Ï†Ä({user_id})"

        names = await asyncio.gather(*(get_name(uid) for uid, _ in top10))

        msg = ["üèÜ Ï£ºÏãù ÏàòÏùµÎ•† Îû≠ÌÇπ"]
        for i, ((uid, profit), name) in enumerate(zip(top10, names), 1):
            msg.append(f"{i}. {name}: ÏàòÏùµÎüâ -> ü´í{profit:+} Ïò¨Î¶¨Î∏å")

        await interaction.followup.send("\n".join(msg), ephemeral=False)  # Ï†ÑÏ≤¥ Í≥µÍ∞ú

    @bot.tree.command(name="Ï£ºÏãùÏ¢ÖÎ™©", description="ÌòÑÏû¨ ÏÉÅÏû•Îêú Î™®Îì† Ï¢ÖÎ™©ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.")
    async def Ï£ºÏãùÏ¢ÖÎ™©(interaction: discord.Interaction):
        stocks = load_json(DATA_FILE)
        msg = ["üìà ÌòÑÏû¨ ÏÉÅÏû• Ï¢ÖÎ™©:"]
        for name, info in stocks.items():
            if info.get("delisted"):
                continue
            price = info["price"]
            history = info.get("history", [price])
            prev = history[-2] if len(history) >= 2 else price
            rate = (price - prev) / prev * 100 if prev else 0
            msg.append(f"- {name}: ü´í{price}Í∞ú Ïò¨Î¶¨Î∏å ({rate:+.2f}%)")
        await interaction.response.send_message("\n".join(msg))

    @bot.tree.command(name="Ï∂îÏÑ∏ÏÑ§Ï†ï", description="ÌäπÏ†ï Ï¢ÖÎ™©Ïùò Ï∂îÏÑ∏Í∞íÏùÑ ÏàòÎèô ÏÑ§Ï†ïÌï©ÎãàÎã§. (Í¥ÄÎ¶¨ÏûêÏö©)")
    @app_commands.describe(name="Ï¢ÖÎ™©Î™Ö", bias="Ï∂îÏÑ∏Í∞í (-0.05 ~ +0.05)")
    @app_commands.autocomplete(name=stock_name_autocomplete)
    async def Ï∂îÏÑ∏ÏÑ§Ï†ï(interaction: discord.Interaction, name: str, bias: float):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        if not (-0.05 <= bias <= 0.05):
            await interaction.response.send_message("Ï∂îÏÑ∏Í∞íÏùÄ -0.05ÏóêÏÑú +0.05 ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§.", ephemeral=True)
            return

        trades = load_json("data/trade_log.json")
        trades.setdefault(name, {"buy": 0, "sell": 0, "bias": 0.0})
        trades[name]["bias"] = round(bias, 4)
        save_json("data/trade_log.json", trades)

        await interaction.response.send_message(f"‚úÖ {name} Ï¢ÖÎ™©Ïùò Ï∂îÏÑ∏ Ìé∏Ìñ•ÏùÑ {bias:+.2%}Î°ú ÏÑ§Ï†ïÌñàÏäµÎãàÎã§.", ephemeral=True)

    @bot.tree.command(name="Ï∂îÏÑ∏ÌòÑÌô©", description="Ï†ÑÏ≤¥ Ï¢ÖÎ™©Ïùò Ï∂îÏÑ∏ Î∞è ÌèâÍ∑†ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§. (Í¥ÄÎ¶¨Ïûê Ï†ÑÏö©)")
    async def Ï∂îÏÑ∏ÌòÑÌô©(interaction: discord.Interaction):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        trades = load_json("data/trade_log.json")
        stocks = load_json(DATA_FILE)
        result = ["üìâ Ï¢ÖÎ™©Î≥Ñ Ï∂îÏÑ∏ Ìé∏Ìñ• ÌòÑÌô©"]
        total = 0
        count = 0

        for name in stocks:
            bias = trades.get(name, {}).get("bias", 0.0)
            result.append(f"- {name}: {bias:+.3f}")
            total += bias
            count += 1

        if count:
            avg = total / count
            result.append(f"\nüìä Ï†ÑÏ≤¥ ÌèâÍ∑† Ï∂îÏÑ∏ Ìé∏Ìñ•: {avg:+.3f}")
        else:
            result.append("‚ö†Ô∏è Ï∂îÏÑ∏ Ìé∏Ìñ• Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")

        await interaction.response.send_message("\n".join(result), ephemeral=True)


    @bot.tree.command(name="Î≥¥Ïú†Ï¢ÖÎ™©", description="ÏûêÏã†Ïù¥ Î≥¥Ïú†Ìïú Ï£ºÏãùÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§. (Î≥∏Ïù∏Îßå Î≥¥Í∏∞)")
    async def Î≥¥Ïú†Ï¢ÖÎ™©(interaction: discord.Interaction):
        user_id = str(interaction.user.id)
        users = load_json(USER_FILE)
        stocks = load_json(DATA_FILE)
        user = users.get(user_id, {})
        holdings = user.get("stocks", {})

        # ÏûêÎèô Ï†ïÎ¶¨: ÏàòÎüâ 0Ïù¥Í±∞ÎÇò ÏÉÅÏû•ÌèêÏßÄÎêú Ï¢ÖÎ™© Ï†úÍ±∞
        cleaned = {
            name: data
            for name, data in holdings.items()
            if data.get("qty", 0) > 0 and name in stocks and not stocks[name].get("delisted")
        }
        user["stocks"] = cleaned
        users[user_id] = user
        save_json(USER_FILE, users)

        if not cleaned:
            await interaction.response.send_message("üì≠ Î≥¥Ïú†Ìïú Ï£ºÏãùÏù¥ ÏóÜÏäµÎãàÎã§.", ephemeral=True)
            return

        msg = ["üì¶ Î≥¥Ïú† Ï¢ÖÎ™© ÌòÑÌô©"]
        for name, data in cleaned.items():
            cur_price = stocks[name]["price"]
            qty = data["qty"]
            avg = data["avg"]
            value = cur_price * qty
            profit = (cur_price - avg) * qty
            emoji = "üî∫" if profit > 0 else "üîª" if profit < 0 else "‚è∏Ô∏è"
            msg.append(f"{name}: {qty}Ï£º | Íµ¨Îß§Í∞Ä: {avg} ‚Üí ÌòÑÏû¨Í∞Ä: {cur_price} | ÌèâÍ∞ÄÍ∏àÏï°: {value} ({emoji} {profit:+})")

        await interaction.response.send_message("\n".join(msg), ephemeral=True)

    @bot.tree.command(name="Îâ¥Ïä§Îì±Î°ù", description="Îâ¥Ïä§Î•º Îì±Î°ùÌï¥ Ï¢ÖÎ™© Ï∂îÏÑ∏Ïóê ÏòÅÌñ•ÏùÑ Ï§çÎãàÎã§.")
    @app_commands.describe(name="Ï¢ÖÎ™©", content="Îâ¥Ïä§ ÎÇ¥Ïö©", influence="Ìò∏Ïû¨(5)~ÏïÖÏû¨(1) Í∞ïÎèÑ")
    @app_commands.autocomplete(name=stock_name_autocomplete)
    async def Îâ¥Ïä§Îì±Î°ù(interaction: discord.Interaction, name: str, content: str, influence: int):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("‚ö†Ô∏è Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        if influence < 1 or influence > 5:
            await interaction.response.send_message("üìâ ÏòÅÌñ•ÎèÑÎäî 1(ÏïÖÏû¨)Î∂ÄÌÑ∞ 5(Ìò∏Ïû¨) ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§.", ephemeral=True)
            return

        news = load_json("data/news_data.json")
        today = datetime.now().strftime("%Y-%m-%d")

        news.setdefault(name, []).append({
            "content": content,
            "influence": influence,
            "date": today,
            "applied": False
        })

        save_json("data/news_data.json", news)
        await interaction.response.send_message(
            f"üì∞ **{name}** Îâ¥Ïä§ Îì±Î°ù ÏôÑÎ£å!\n`{content}` (ÏòÅÌñ•ÎèÑ: {influence})", ephemeral=True)

    @bot.tree.command(name="ÏÉÅÏû•ÌèêÏßÄ", description="ÏßÄÏ†ïÌïú Ï¢ÖÎ™©ÏùÑ ÏàòÎèô ÌèêÏßÄÌï©ÎãàÎã§.")
    @app_commands.describe(name="Ï¢ÖÎ™© Ïù¥Î¶Ñ")
    @app_commands.autocomplete(name=StockNameConverter().autocomplete)
    async def ÏÉÅÏû•ÌèêÏßÄ(interaction: discord.Interaction, name: str):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("‚ö†Ô∏è Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        with open("data/stock_data.json", "r", encoding="utf-8") as f:
            stock_data = json.load(f)

        if name not in stock_data:
            await interaction.response.send_message("‚ùå Ìï¥Îãπ Ï¢ÖÎ™©ÏùÄ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.", ephemeral=True)
            return

        del stock_data[name]

        with open("data/stock_data.json", "w", encoding="utf-8") as f:
            json.dump(stock_data, f, ensure_ascii=False, indent=2)

        await interaction.response.send_message(f"üóëÔ∏è `{name}` Ï¢ÖÎ™©Ïù¥ ÏÉÅÏû•ÌèêÏßÄÎêòÏñ¥ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.")


    @bot.tree.command(name="Îâ¥Ïä§ÏÇ≠Ï†ú", description="ÌäπÏ†ï Ï¢ÖÎ™©Ïùò Îâ¥Ïä§Î•º Î™®Îëê ÏÇ≠Ï†úÌï©ÎãàÎã§.")
    @app_commands.describe(name="Îâ¥Ïä§Î•º ÏÇ≠Ï†úÌï† Ï¢ÖÎ™© Ïù¥Î¶Ñ")
    @app_commands.autocomplete(name=stock_name_autocomplete)
    async def Îâ¥Ïä§ÏÇ≠Ï†ú(interaction: discord.Interaction, name: str):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("‚ö†Ô∏è Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        news = load_json("data/news_data.json")
        if name not in news or not news[name]:
            await interaction.response.send_message("Ìï¥Îãπ Ï¢ÖÎ™©Ïóê Îì±Î°ùÎêú Îâ¥Ïä§Í∞Ä ÏóÜÏäµÎãàÎã§.", ephemeral=True)
            return

        del news[name]
        save_json("data/news_data.json", news)
        await interaction.response.send_message(f"üóëÔ∏è `{name}`Ïùò Î™®Îì† Îâ¥Ïä§Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.", ephemeral=True)

    @bot.tree.command(name="Îâ¥Ïä§Ï†ÑÏ≤¥ÏÇ≠Ï†ú", description="Î™®Îì† Ï¢ÖÎ™©Ïùò Îâ¥Ïä§Î•º ÏùºÍ¥Ñ ÏÇ≠Ï†úÌï©ÎãàÎã§.")
    async def Îâ¥Ïä§Ï†ÑÏ≤¥ÏÇ≠Ï†ú(interaction: discord.Interaction):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("‚ö†Ô∏è Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        save_json("data/news_data.json", {})  # Îπà ÎîïÏÖîÎÑàÎ¶¨Î°ú ÎçÆÏñ¥Ïì∞Í∏∞
        await interaction.response.send_message("üßπ Î™®Îì† Îâ¥Ïä§Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.", ephemeral=True)

    @bot.tree.command(name="Ï¢ÖÎ™©Ï∂îÍ∞Ä", description="ÏÉàÎ°úÏö¥ Ï¢ÖÎ™©ÏùÑ Îì±Î°ùÌï©ÎãàÎã§. (Í¥ÄÎ¶¨Ïûê Ï†ÑÏö©)")
    @app_commands.describe(name="Ï¢ÖÎ™©Î™Ö", price="Ï¥àÍ∏∞ Ï£ºÍ∞Ä")
    async def Ï¢ÖÎ™©Ï∂îÍ∞Ä(interaction: discord.Interaction, name: str, price: int):
        if interaction.user.id not in ADMIN_IDS:
            await interaction.response.send_message("‚ö†Ô∏è Í¥ÄÎ¶¨ÏûêÎßå ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.", ephemeral=True)
            return

        stocks = load_json(DATA_FILE)
        if name in stocks:
            await interaction.response.send_message("‚ùå Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Ï¢ÖÎ™©ÏûÖÎãàÎã§.", ephemeral=True)
            return

        stocks[name] = {
            "price": price,
            "trend": "up",
            "bias": 0,
            "locked": False,
            "history": [],
            "trend_days": 0
        }

        save_json(DATA_FILE, stocks)
        await interaction.response.send_message(
            f"‚úÖ `{name}` Ï¢ÖÎ™©Ïù¥ ü´í {price} Ïò¨Î¶¨Î∏åÎ°ú Îì±Î°ùÎêòÏóàÏäµÎãàÎã§.", ephemeral=True)


    @bot.tree.command(name="Ï£ºÏãùÍ∑∏ÎûòÌîÑ", description="ÌäπÏ†ï Ï¢ÖÎ™©Ïùò Í∞ÄÍ≤© Î≥ÄÎèô Í∑∏ÎûòÌîÑÎ•º ÌôïÏù∏Ìï©ÎãàÎã§.")
    @app_commands.describe(name="ÌôïÏù∏Ìï† Ï¢ÖÎ™©Î™Ö")
    @app_commands.rename(name="Ï¢ÖÎ™©")
    @app_commands.autocomplete(name=StockNameConverter().autocomplete)
    async def Ï£ºÏãùÍ∑∏ÎûòÌîÑ(interaction: discord.Interaction, name: str):
        with open("data/stock_data.json", "r", encoding="utf-8") as f:
            stock_data = json.load(f)

        if name not in stock_data:
            await interaction.response.send_message("‚ùå Ìï¥Îãπ Ï¢ÖÎ™©Ïù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.", ephemeral=True)
            return

        history = stock_data[name].get("history", [])
        if len(history) < 2:
            await interaction.response.send_message("üìâ Ìï¥Îãπ Ï¢ÖÎ™©ÏùÄ Í∏∞Î°ùÎêú Í∞ÄÍ≤© Î≥ÄÌôîÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.", ephemeral=True)
            return

        plt.style.use('ggplot')
        fig, ax = plt.subplots(figsize=(10, 5))

        x = np.arange(len(history))
        y = np.array(history)
        ax.plot(x, y, marker="o", linewidth=2.5, label=name)

        ax.set_title(f"üìà {name} Í∞ÄÍ≤© Î≥ÄÌôî Ï∂îÏù¥", fontsize=16, weight='bold')
        ax.set_xlabel("Í∞±Ïã† ÏàúÏÑú", fontsize=12)
        ax.set_ylabel("Í∞ÄÍ≤© (Ïò¨Î¶¨Î∏å)", fontsize=12)
        ax.tick_params(axis='both', labelsize=10)
        ax.grid(True, alpha=0.3)
        ax.legend(fontsize=10)
        fig.tight_layout()

        path = "stock_graph.png"
        fig.savefig(path, dpi=180)
        plt.close(fig)

        await interaction.response.send_message(file=discord.File(path))